import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize
df = pd.read_csv('/content/data.csv', encoding='latin1',low_memory=False)
df.columns
x = pd.to_numeric(df['no2'], errors='coerce').dropna().values
print(x)
r = 102303699
mod7 = r % 7
mod5 = r % 5
a_r = 0.05 * mod7
b_r = 0.3 * (mod5 + 1)
print('a_r : ',a_r,' b_r : ',b_r)
z = x + a_r * np.sin(b_r * x)
print(z)
def negative_log_likelihood(params, z_data):
    lam, mu = params
    if lam <= 0: return 1e18
    c = np.sqrt(lam / np.pi)
    p = c * np.exp(-lam * (z_data - mu)**2)
    # The 1e-9 floor makes this a robust MLE
    return -np.sum(np.log(p + 1e-9))
res = minimize(negative_log_likelihood, [0.0018, 25.34], args=(z,),
               method='L-BFGS-B', tol=1e-12)

lam_acc, mu_acc = res.x
c_acc = np.sqrt(lam_acc / np.pi)

print(f"Refined Lambda: {lam_acc:.8f}")
print(f"Refined Mu:     {mu_acc:.8f}")
print(f"Refined c:      {c_acc:.8f}")
